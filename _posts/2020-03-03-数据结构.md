---
layout: post
title: 『数据结构学习笔记』
categories: Blog
description: 数据结构
keywords: 数据结构, Notes
---

### 1.1.1、关于空间使用

写一个程序实现一个函数 PrintN，似地传入一个正整数为 N 的参数后，能顺序打印从 1 到 N 全部正整数。

- **循环实现( 占用空间小)**

  ```C
  void PrintN(int n)
  {
      fro (int i =1; i <= n; i++) {
          cout << i << ' ';
      }
      return 0;
  }
  ```

- **递归实现(占用空间大)**

  ```C
  void PrintN(int n)
  {
      if (n){
          Print(n - 1);
          cout << n << ' ';
      }
      return 0;
  }
  ```

### 1.1.2、关于算法效率

写程序计算给定多项式在给定点 x 处的值：
$$
f(x) =a_0 + a_1x + ... + a_{n-1}x^{n-1} + a_nx^n
$$

- **一般算法(效率低)**

  ```C
  double f(int n, double a[], double x) {
      double p = a[0];
      for (int i = 1; i <= n; i++) {
          p += (a[i] * pow(x, i));
      }
      return p;
  }
  ```

- **秦九韶算法(效率高)**
  $$
  f(x) = a_0 + x(a_1 + x(...(a_{n-1} + x(a_n))...))
  $$

  ```C
  double f (int n, double a[], double x) {
      double p = a[n];
      for (int i = n; i > 0; i--) {
          p = a[i -1 ] + x * p;
      }
      return p;
  }
  ```

- **clock():**捕捉从程序开始运行到 clock() 被调用时所耗费的时间。单位是 clock tick，即“时钟打点”

  常数 CLK_TCK：机器时钟每秒所走的时钟打点数。

  ```C
  # include <stdio.h>
  # include <time.h>
  
  clock_t start, stop;
  double duration;
  int main()
  {
      start = clock();
      MyFunction();
      stop = clock();
      duration = (double(stop - start)) / CLK_TCK;
      return 0;
  }
  ```

### 1.1.3、抽象数据类型(Abstract Data Type)

- 数据类型
  - 数据对象集
  - 数据集合相关联的操作集

- 抽象：描述数据类型的方法不依赖于具体实现

  - 与存放数据的机器无关
  - 与数据存储的物理结构无关
  - 与实现操作的算法和编程语言均无关

  只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题。

- 举例：

  - **类型名称：**矩阵(Matrix)
  - **数据对象集：**一个 MxN 的矩阵![image](/images/blog/数据结构/Matrix.png)由MxN个三元组 <a, i, j> 构成，其中 a 是矩阵元素的值，i 是元素所在的行号，j 是元素所在的列号。
  - **操作集：**对于任意矩阵 A、B、C 属于 Matrix，以及整数 i、j、k、M、N
    - Matrix Creat(int M, int N)：返回一个 MxN 的空矩阵;
    - int GetMaxRow(Matrix A)：返回矩阵 A 的总行数;
    - ElementType GetEntry(Matrix A, int i, int j): 返回矩阵 A 的第 i 行、第 j 列的元素;
    - Matrix Add(Matrix A, Matrux B): 如果 A 和 B 的行、列数一致，则返回矩阵 C = A + B，否则返回错误标志;
    - Matrix Multiply(Matrix A, Matrix B): 如果 A 的列数等于 B 夫人行数，则返回矩阵 C = AB，否则返回错误标志;
    - ......

### 1.2.1、算法(Algorithm)

- 一个有限指令集
- 接受一些输入（有些情况下不需要输入）
- 产生输出
- 一定在有限步骤之后停止
- 每一条指令必须：
  - 有明确的目标，不可以有歧义
  - 计算机能处理的范围内
  - 描述应不以来于任何一门计算机语言以及具体的实现手段

**举例：选择排序算法的伪代码描述**

```C
void SelectionSort(int List[], int N) {
    /*将 N 个List[0]...List[N-1] 进行非递减排序*/
    for(i = 0; i < N; i++) {
        MinPosition = ScanForMin(List, i, N-1);
        /*从 List[i] 到 List[N-1] 中找最小元，并将其位置赋给 MinPosition*/
        Swap(List[i], List[MinPosition]);
        /*将未排序的部分的最小元换到有序部分的最后位置*/
    }
}
```

- 空间复杂度S(n)：根据算法写成的程序在执行时**占用储存元的长度**。
- 时间复杂度T(n)：根据算法写成的程序在执行时**耗费时间的长度**。

举例1：

```C
void PrintN(int N) {
    if(N) {
        Print(N - 1);
        print("%d\n", N);
    }
}
```

举例2：

```C
double f(int n, double a[], double x) {
    double p = a[0];
    for (int i = 1; i <= n; i++) {
        p += (a[i] * pow(x, i));
    }
    return p;
}

double f (int n, double a[], double x) {
    double p = a[n];
    for (int i = n; i > 0; i--) {
        p = a[i -1 ] + x * p;
    }
    return p;
}
```

### 1.2.1、应用实例

#### 最大子列和问题：

$$
给定 N 个着呢个书的序列 {A1, A2, ..., An}，求函数f(i, j)=max(0, \sum_{k=i}^jA_k)的最大值：
$$

- 算法1：

  ```C
  int MaxSubseqSum(int A[], int N) {
      int ThisSum, MaxSum = 0;
      int i, j, k;
      for(i = 0; i < N; i++) { // i 是子列左端位置
          for(j = i; j < N; j++) { // j是子列右端位置
              ThisSum = 0; // ThisSum 是从 A[i] 到 A[j] 的子列和
              for(k = i; k <= j; k++)
                  ThisSum += A[k];
             	if(ThisSum > MaxSum) // if True
                  MaxSum = ThisSum;// 更新结果
          }
      }
      return MaxSum;
  }
  ```

  $$
  复杂度：T(N)=O(N^3)
  $$

- 算法2：

  ```c
  int MaxSubseqSum(int A[], int N) {
      int ThisSum, MaxSum = 0;
      int i, j;
      for(i = 0; i < N; i++) { // i 是子列左端位置
          ThisSum = 0; // ThisSum 是从 A[i] 到 A[j] 的子列和
          for(j = i; j < N; j++) { // j是子列右端位置
              ThisSum += A[j];
          if(ThisSum > MaxSum) // if True
              MaxSum = ThisSum; // 更新结果
          }
      }
      return MaxSum;
  }
  ```

  
  $$
  复杂度：T(N)=O(N^2)
  $$

- 算法3：分治

  ![image](/images/blog/数据结构/分治.png)

  ```c
  static int Find_Max_Crossing_SubArray(int * nums, int start, int mid, int end) {
      int left = -65533, right = -65533;
      int sum;
      int i, j;
  
      sum = 0;
      for(i = mid; i >= start; i--) {
          sum += *(nums + i);
          if(sum > left) {
              left = sum;
          }
      }
  
      sum = 0;
      for(j = mid + 1; j < end; j++) {
          sum += *(nums + j);
          if(sum > right) {
              right = sum;
          }
      }
  
      return left + right;
  }
  
  int Find_Maximum_Subarray(int * nums, int start, int end) {
      int left;
      int right;
      int cross;
      int mid;
  
      if(start == end)
          return * nums;
      else
      {
          mid = (start + end)/2;
          left = Find_Maximum_Subarray(nums, start, mid);
          right = Find_Maximum_Subarray(nums, mid + 1, end);
          cross = Find_Max_Crossing_SubArray(nums, start, mid, end);
           
          if(left >= right && left >= cross)
              return left;
          else if(right >= left && right >= cross)
              return right;
          else
              return cross;
      }
  }
  
  int main()
  {
      int arr[] = {13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7}, * nums = arr;
      int val;
  
      val = Find_Maximum_Subarray(nums, 0, sizeof(arr)/sizeof(int));
      printf("MaxSubarraySum = %d.\n", val);
      return 0;
  }
  ```

  $$
  复杂度：T(N)=O(NlogN)
  $$

- 算法4：在线处理

  ```C
  int MaxSubSum(int A[], int N) {
      int ThisSum, MaxSum, i;
      ThisSum = MaxSum = 0;
      for(i = 0; i < N; i++) {
          ThisSum += A[i]; //每次循环则累加
          if(ThisSum > MaxSum) //每次循环，如果成立则MaxSum的值就会变为ThisSum
              MaxSum = ThisSum;
          else if(ThisSum < 0) //每次循环，如果成立则ThisSum重新置为0
              ThisSum = 0;
      }
      return MaxSum;
  }
  ```

  $$
  复杂度：T(N)=O(N)
  $$

 ### 2、线性结构

#### 2.1.1、多项式表示

**[例]：一元多项式及其计算**

**一元多项式**:![image](/images/blog/数据结构/fx.png)

**主要运算**：多项式相加、相减、相乘等

**[分析]：如何表示多项式**

- 关键数据：
  - 多项式项数 n
  - 各项系数![image](/images/blog/数据结构/ai.png)及指数 i

- 表示方法：

  - **方法1：顺序存储结构直接表示(虽然方便，但是空间浪费)**

    ![image](/images/blog/数据结构/2.1.1_1.png)

  - **方法2：顺序储存结构表示非零项**

    ![image](/images/blog/数据结构/2.1.1_2.png)

    ![image](/images/blog/数据结构/2.1.1_3.png)